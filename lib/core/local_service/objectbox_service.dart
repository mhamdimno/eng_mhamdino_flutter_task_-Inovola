// lib/core/local/objectbox_service.dart
// ignore_for_file: depend_on_referenced_packages

import 'package:flutter/foundation.dart'; // For debugPrint
import 'package:injectable/injectable.dart';
import 'package:objectbox/objectbox.dart'; // ObjectBox core
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

import '../../features/dropdowns/categories/data/model/cateogory_model.dart';
import '../../objectbox.g.dart'; // Generated by `flutter pub run build_runner build`
import 'local_service.dart';

// @LazySingleton(as: LocalService)
// // Register as the generic LocalService
@LazySingleton(as: LocalService)
class ObjectBoxService implements LocalService {
  final Store _store;

  // Private constructor to ensure proper initialization via `create` or injectable
  ObjectBoxService._(this._store);

  @factoryMethod // Indicates that this static method is the factory for creating the instance
  static Future<ObjectBoxService> create() async {
    debugPrint("Initializing ObjectBox Store...");
    final dir = await getApplicationDocumentsDirectory();
    final store =
        await openStore(directory: p.join(dir.path, "objectbox_data"));
    debugPrint("ObjectBox Store initialized.");

    return ObjectBoxService._(store);
  }

  /// Helper to get the Box for a given type [T].
  /// Throws an error if the type [T] is not an ObjectBox Entity.
  Box<T> _getBox<T>() {
    try {
      return _store.box<T>();
    } catch (e) {
      debugPrint(
          "Error: Type $T is not an ObjectBox Entity. Did you annotate it with @Entity() and run build_runner?");
      rethrow;
    }
  }

  @override
  Future<int> put<T>(T object) async {
    try {
      final box = _getBox<T>();
      return box.put(object);
    } catch (e) {
      debugPrint("Error putting object: $e");
      throw Exception("Failed to put object: $e");
    }
  }

  @override
  Future<List<int>> putMany<T>(List<T> objects) async {
    try {
      final box = _getBox<T>();
      // ObjectBox's putMany returns the IDs of the put objects directly.
      // If the object was new, it will return the new ID.
      // If it was an update, it returns the existing ID.
      return box.putMany(objects);
    } catch (e) {
      debugPrint("Error putting many objects: $e");
      throw Exception("Failed to put many objects: $e");
    }
  }

  @override
  Future<T?> getById<T>(int id) async {
    try {
      final box = _getBox<T>();
      return box.get(id);
    } catch (e) {
      debugPrint("Error getting object by ID: $e");
      throw Exception("Failed to get object by ID: $e");
    }
  }

  @override
  Future<List<T>> getAll<T>() async {
    try {
      final box = _getBox<T>();
      return box.getAll();
    } catch (e) {
      debugPrint("Error getting paginated objects: $e");
      throw Exception("Failed to get paginated objects: $e");
    }
  }

  // Assuming T is the type of items in your box
  @override
  Future<List<T>> getPaginatedData<T>(int page, int pageSize) async {
    final box = _getBox<T>();
    final allItems = box.getAll(); // Retrieve all items from the box

    final startIndex = (page - 1) * pageSize;
    if (startIndex < 0 || startIndex >= allItems.length) {
      return []; // Return empty if startIndex is out of bounds
    }

    final endIndex = startIndex + pageSize;
    if (endIndex > allItems.length) {
      return allItems.sublist(
          startIndex, allItems.length); // Get remaining items
    }

    return allItems.sublist(startIndex, endIndex); // Get the paginated slice
  }

  @override
  Future<bool> deleteById<T>(int id) async {
    try {
      final box = _getBox<T>();
      return box.remove(id);
    } catch (e) {
      debugPrint("Error deleting object by ID: $e");
      throw Exception("Failed to delete object by ID: $e");
    }
  }

  @override
  Future<int> deleteMany<T>(List<int> ids) async {
    try {
      final box = _getBox<T>();
      return box.removeMany(ids);
    } catch (e) {
      debugPrint("Error deleting many objects: $e");
      throw Exception("Failed to delete many objects: $e");
    }
  }

  @override
  Future<List<T>> query<T>(Condition<T> condition) async {
    try {
      // final box = _getBox<T>();
      // final queryBuilder = box.query();
      // final query = queryBuilder.where(condition).build();
      // final result = query.find();
      // query.close(); // Important: close the query when done
      // return result;
      return [];
    } catch (e) {
      debugPrint("Error querying objects: $e");
      throw Exception("Failed to query objects: $e");
    }
  }

  @override
  Future<void> close() async {
    _store.close();
  }
}
